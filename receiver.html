<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="apple-touch-icon" href="favicon.png">
  <link rel="shortcut icon" href="favicon.ico">
  <meta charset="UTF-8">
  <title>BotChime Receiver</title>
  <style>
    body {
      background-color: #222;
      color: white;
      text-align: center;
      font-family: sans-serif;
    }
    canvas {
      border: 1px solid #ccc;
      margin-top: 20px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
    }
    h1 {
      margin-bottom: 1rem;
      color: orange;
    }
    #statusContainer {
      position: relative;
      width: 80%;
      max-width: 600px;
      height: 60px;
      margin: 20px auto 5px;
      background-color: #444;
      border-radius: 8px;
      overflow: hidden;
    }

    #statusBar {
      height: 100%;
      width: 0%;
      background-color: limegreen;
      transition: width 0.1s linear;
    }

    #statusText {
      position: absolute;
      width: 100%;
      text-align: center;
      top: 0;
      line-height: 60px;
      font-size: 24px;
      font-weight: bold;
      color: black;
    }

    #recordIcon {
      text-align: center;
      font-size: 48px;
      color: red;
      display: none;
      animation: pulse 1.2s infinite ease-in-out;
    }

    @keyframes pulse {
      0%   { transform: scale(1);   opacity: 1; }
      50%  { transform: scale(1.2); opacity: 0.6; }
      100% { transform: scale(1);   opacity: 1; }
    }


  </style>
</head>
<body>
  <h1 style="font-size: 68px;">BotChime Receiver</h1>
  <canvas id="powerCanvas" width="600" height="200"></canvas>
  <br>
  <canvas id="raster" width="600" height="400"></canvas>
  <br>
  <canvas id="combinedLabels" width="600" height="60"></canvas>
  <br>
  <p id="decodedMessage" style="font-size: 96px; color: #ff0; font-family: monospace;"></p>
  <div id="buttonContainer">
    <button id="startBtn" disabled>üéôÔ∏è Start Recording</button>
    <button id="stopBtn" disabled>üéôÔ∏è Stop Recording</button>
  </div>
  <div id="recordIcon">üî¥</div>
  <script>


    // === CONFIGURATION CONSTANTS ===

    // üéöÔ∏è Spectrogram & Display
    const SYNC_POWER_THRESHOLD_DB = 10;    // dB threshold for sync signal onset/offset
    const CHORD_CHANGE_THRESHOLD = 8;
    const RASTER_THRESHOLD_DB = 18;
    const POWER_TRACE_MIN_HZ = 500;         // Min frequency for broadband power
    const POWER_TRACE_MAX_HZ = 6000;        // Max frequency for broadband power
    const DURATION = 8;                    // Recording duration in seconds
    const INTERVAL_MS = 1;                 // Frame interval in milliseconds
    const PITCH_BANDWIDTH = 10;         // Hz, vertical height of mask box

    // üéõÔ∏è FFT & Spectrogram Settings
    const FFT_SIZE = 2048;
    const HOP_SIZE = 1024;

    // üé® Plotting
    const MIN_DB = -3;
    const MAX_DB = 25;
    const LABEL_MARGIN = 50;  // global

    // üé∂ Chord Data Defaults (loaded later)
    let PROGRESSIONS = {};
    let ALLOWED_CHARS = {};
    let CHORDS = {};
    let NOTE_FREQS = {};
    let FREQS = [];
    let SYMBOL_DURATION = [];
    let binToNote = [];

    const PITCHES = ["B2", "B3", 
      "C5", "C#5", "D5", "D#5", "E5", "F5", "F#5",
      "G5", "G#5", "A5", "A#5", "B5",
      "C6", "C#6", "D6", "D#6", "E6", "F6", "F#6",
      "G6", "G#6", "A6", "A#6", "B6",
      "C7", "C#7", "D7", "D#7", "E7", "F7", "F#7",
      "G7", "G#7", "A7", "A#7", "B7",
      "C8", "C#8", "D8", "D#8", "E8", "F8", "F#8",
      "G8", "G#8", "A8", "A#8", "B8"
    ];


    let passiveAudioCtx = null;
    let passiveStream = null;
    let passiveProcessor = null;
    let passiveSource = null;

    let peakBeforeDrop = null;
    let fallSampleIndex = null;
    let onsetTimeoutSamples = null;
    let minOffsetSampleIndex = null;


    document.getElementById("startBtn").onclick = startPassiveReceiver;
    document.getElementById("stopBtn").onclick = stopPassiveReceiver;

    // Load shared musical data
    fetch("constants.json")
      .then(res => res.json())
      .then(data => {
        PROGRESSIONS = data.PROGRESSIONS;
        CHORDS = data.CHORDS;
        NOTE_FREQS = data.NOTE_FREQS;
        SYMBOL_DURATION = data.SYMBOL_DURATION;
        ALLOWED_CHARS = data.ALLOWED_CHARS;

        // Convert NOTE_FREQS { C4: 261.63, ... } to array [{ name, freq }]
        FREQS = Object.entries(NOTE_FREQS).map(([name, freq]) => ({ name, freq }));

        startBtn.disabled = false;  // ‚úÖ enable passive mode
        stopBtn.disabled = false;
      })
      .catch(err => {
        startBtn.disabled = true;
      });



    // === Audio input ===
    // === Continuous Passive Receiver with Real-Time Snip ===
    let passiveListening = false;

    let fullSampleBuffer = [];         // Stores all samples
    let sampleRate = null;             // Set by AudioContext

    async function startPassiveReceiver() {
      passiveListening = true;

      // Toggle buttons
      document.getElementById("startBtn").disabled = true;
      document.getElementById("stopBtn").disabled = false;
      document.getElementById("recordIcon").style.display = "none";

      passiveStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      passiveAudioCtx = new AudioContext();
      passiveSource = passiveAudioCtx.createMediaStreamSource(passiveStream);
      passiveProcessor = passiveAudioCtx.createScriptProcessor(4096, 1, 1);


      passiveSource.connect(passiveProcessor);
      passiveProcessor.connect(passiveAudioCtx.destination);


      const sampleRate = passiveAudioCtx.sampleRate;
      const ringLength = sampleRate * 10; // 10 seconds
      const ringPcm = new Float32Array(ringLength);
      let ringWriteIndex = 0;
      let absoluteSampleIndex = 0;

      // Frequency band for meta signal
      const analyser = passiveAudioCtx.createAnalyser();
      analyser.fftSize = 2048;
      passiveSource.connect(analyser);
      const binMin = Math.floor(noteToFreq("C5") / (sampleRate / analyser.fftSize));
      const binMax = Math.ceil(noteToFreq("A#5") / (sampleRate / analyser.fftSize));
      const dataArray = new Float32Array(analyser.frequencyBinCount);

      // State
      const ringBuffer = [];
      const ringSize = Math.floor(sampleRate * 20 / 2048); // ~0.5s worth
      let triggered = false;
      let onsetSampleIndex = null;
      let offsetSampleIndex = null;
      let minOffsetSampleIndex = null;
      let fallSampleIndex = null;
      let peakBeforeDrop = null;
      let lastTriggerTime = -Infinity;
      const triggerCooldown = 10; // in milliseconds
      let triggerWallClockTime = null; // in ms
      const timeoutDurationMs = 3200;  // 8 seconds
      let forcedByTimeout = false;


      passiveProcessor.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        for (let i = 0; i < input.length; i++) {
          ringPcm[ringWriteIndex] = input[i];
          ringWriteIndex = (ringWriteIndex + 1) % ringPcm.length;
        }
        absoluteSampleIndex += input.length;

        // Spectral power
        analyser.getFloatFrequencyData(dataArray);
        let sum = 0;
        let validBins = 0;
        for (let i = binMin; i <= binMax; i++) {
          const val = dataArray[i];
          if (Number.isFinite(val)) {
            sum += val;
            validBins++;
          }
        }
        const avg = validBins > 0 ? sum / validBins : -Infinity;
        ringBuffer.push(avg);
        if (ringBuffer.length > ringSize) ringBuffer.shift();

        const finiteRing = ringBuffer.filter(Number.isFinite);
        const baseline = finiteRing.length > 0 ? finiteRing.reduce((a, b) => a + b, 0) / finiteRing.length : -Infinity;
        const dynamicSpikeThreshold = 12; // dB above rolling baseline
        // const offsetThreshold = 10;

        // Onset
        const now = performance.now();

        if (
          !triggered &&
          (avg - baseline) > dynamicSpikeThreshold &&
          Number.isFinite(avg) && Number.isFinite(baseline) &&
          (now - lastTriggerTime > triggerCooldown)
        ) {
          triggered = true;
          triggerWallClockTime = performance.now();
          onsetSampleIndex = absoluteSampleIndex;
          minOffsetSampleIndex = onsetSampleIndex + Math.floor(sampleRate * 1.0);
          peakSinceOnset = avg;
          lastTriggerTime = now;
          document.getElementById("recordIcon").style.display = "block";
        }


        // Offset logic
        if (
          triggered &&
          triggerWallClockTime &&
          now - triggerWallClockTime > timeoutDurationMs &&
          !offsetSampleIndex // prevent looping
        ) {
          offsetSampleIndex = absoluteSampleIndex;
          forcedByTimeout = true;
        }


        if (triggered && absoluteSampleIndex > minOffsetSampleIndex) {

          // Continuously update peak
          if (avg > peakSinceOnset) peakSinceOnset = avg;

          // Check for fall below threshold relative to peak
          const dropThreshold = 12; // dB
          if (!fallSampleIndex && avg < (peakSinceOnset - dropThreshold)) {
            fallSampleIndex = absoluteSampleIndex;
            peakBeforeDrop = peakSinceOnset;
          }

          // Confirm offset after 1s of quiet
          if (fallSampleIndex && absoluteSampleIndex > fallSampleIndex + sampleRate * 1.0) {
            const reboundThreshold = peakBeforeDrop + 12; // rebound if signal climbs back up
            const hasRebounded = ringBuffer.some(v => v > reboundThreshold);

            if (!hasRebounded) {
              offsetSampleIndex = absoluteSampleIndex;
            } else {
              fallSampleIndex = null;
              peakBeforeDrop = null;
              peakSinceOnset = avg; // reset peak
            }
          }


          if (offsetSampleIndex) {
            const prerollDuration = 2.0; // seconds
            const prerollSamples = Math.floor(sampleRate * prerollDuration);
            const start = Math.max(0, onsetSampleIndex - prerollSamples);
            const end = offsetSampleIndex;
            const sliceLength = end - start;
            const sliced = new Float32Array(sliceLength);

            for (let i = 0; i < sliceLength; i++) {
              const ringIndex = (start + i) % ringPcm.length;
              sliced[i] = ringPcm[ringIndex];
            }


            const segmentBuffer = passiveAudioCtx.createBuffer(1, sliceLength, sampleRate);
            segmentBuffer.copyToChannel(sliced, 0);

            processAudioBuffer(segmentBuffer);


            // Reset
            triggered = false;
            onsetSampleIndex = null;
            offsetSampleIndex = null;
            fallSampleIndex = null;
            peakBeforeDrop = null;
            triggerWallClockTime = null;
            forcedByTimeout = false;
            document.getElementById("recordIcon").style.display = "none";

          }
        }
      };

    }




    function stopPassiveReceiver(segmentBuffer) {
      passiveListening = false;

      // Toggle buttons
      document.getElementById("startBtn").disabled = false;
      document.getElementById("stopBtn").disabled = true;
      // processAudioBuffer();
      stopBtn.disabled = true;
      startBtn.disabled = false;
      document.getElementById("recordIcon").style.display = "none";

      if (passiveProcessor) {
        passiveProcessor.disconnect();
        passiveProcessor.onaudioprocess = null;
        passiveProcessor = null;
      }

      if (passiveSource) {
        passiveSource.disconnect();
        passiveSource = null;
      }

      if (passiveAudioCtx && passiveAudioCtx.state !== 'closed') {
        passiveAudioCtx.close();
        passiveAudioCtx = null;
      }

      if (passiveStream) {
        passiveStream.getTracks().forEach(track => track.stop());
        passiveStream = null;
      }

    }




    // === Trigger ===
    function updateTriggerLogic(metaPower, sampleRate) {
      metaPowerHistory.push(metaPower);
      if (metaPowerHistory.length > maxHistory) metaPowerHistory.shift();

      const avgRecent = metaPowerHistory.slice(0, -2).reduce((a, b) => a + b, 0) / (metaPowerHistory.length - 2 || 1);
      const boostThreshold = 6; // dB above local average
      const decayThreshold = 2; // dB below recent average

      if (!isTriggered && metaPower > avgRecent + boostThreshold) {
        isTriggered = true;
        onsetSampleIndex = fullSampleBuffer.length;
      }

      if (isTriggered && metaPower < avgRecent - decayThreshold) {
        const offsetSampleIndex = fullSampleBuffer.length;
        const pre = Math.floor(sampleRate * 1.0);
        const post = Math.floor(sampleRate * 1.0);
        const start = Math.max(0, onsetSampleIndex - pre);
        const end = offsetSampleIndex + post;
        const sliced = Float32Array.from(fullSampleBuffer.slice(start, end));

        const audioBuffer = audioCtx.createBuffer(1, sliced.length, sampleRate);
        audioBuffer.copyToChannel(sliced, 0);

        processAudioBuffer(audioBuffer);

        isTriggered = false;
        onsetSampleIndex = null;
        metaPowerHistory.length = 0; // Clear history for next detection

        // Optionally trim old samples
        const maxSamples = 10 * sampleRate;
        if (fullSampleBuffer.length > maxSamples) {
          const cutoff = fullSampleBuffer.length - maxSamples;
          fullSampleBuffer = fullSampleBuffer.slice(cutoff);
        }

      }
    }



    // === Main pipeline ===
    async function processAudioBuffer(audioBuffer) {
      const raw = audioBuffer.getChannelData(0);
      const sampleRate = audioBuffer.sampleRate;

      const { Sxx_dB, freqs, times } = computeSpectrogram(raw, sampleRate);
      const { metaTrace, dataTrace, metaDetrended, dataDetrended, signalDetrended } = computeMetaAndDataTraces(Sxx_dB, freqs);
      const timeStep = times[1] - times[0];

      const dynamicThreshold = 0.73 * Math.max(...metaDetrended);
      const { onsetIndex, offsetIndex } = detectPowerRiseOnset(metaDetrended, timeStep);

      drawPowerTraces(metaDetrended, dataDetrended, signalDetrended, timeStep, {
        onsetIndex,
        offsetIndex
      });

      const PHASE_SWEEP = [-0.04, -0.03, -0.02, -0.01, 0, 0.01, 0.02, 0.03, 0.04, 0.05];

      const sweepConfigs = [];
      const thresholdFactors = [0.3, 0.4, 0.5, 0.6, 0.7];  // ‚Üê Add more if needed

      for (let alpha = 0.3; alpha <= 0.5; alpha += 0.025) {
        for (let offset = -4; offset <= -2; offset += 0.25) {
          for (const thresholdFactor of thresholdFactors) {
            sweepConfigs.push({
              alpha: parseFloat(alpha.toFixed(3)),
              offset: parseFloat(offset.toFixed(2)),
              thresholdFactor: thresholdFactor
            });
          }
        }
      }


      let bestCandidate = null;
      let allCandidates = [];

      for (const phaseOffset of PHASE_SWEEP) {
        const onsetIndexAdj = onsetIndex + Math.round(phaseOffset / timeStep);
        const messageDuration = (offsetIndex - onsetIndexAdj) * timeStep;
        const numSymbols = Math.floor(messageDuration / SYMBOL_DURATION) + 1;
        const raster = computeRaster(Sxx_dB, freqs, times, SYMBOL_DURATION, onsetIndexAdj, numSymbols);
        let detrendedRaster = detrendRasterOverFrequency(raster);
        detrendedRaster = detrendRasterOverTimeUsingNoisePitches(detrendedRaster);
        const chordChangeVector = computeChordChangeVectorFromRaster(detrendedRaster);
        const chordPerSymbol = expandChordVector(detrendedRaster, chordChangeVector);

        for (const cfg of sweepConfigs) {

          // Get signal max
          const signalMax = Math.max(...detrendedRaster.flat());

          // Compute average noise level across all columns in B5 and C#8 rows
          const noiseRows = [noteToIndex('B5'), noteToIndex('C#8')];
          let noiseSum = 0;
          let count = 0;
          for (const rowIdx of noiseRows) {
            for (let col = 0; col < detrendedRaster[rowIdx].length; col++) {
              noiseSum += detrendedRaster[rowIdx][col];
              count++;
            }
          }
          const noiseAvg = noiseSum / count;

          // Compute midpoint threshold
          const midpointThreshold = cfg.thresholdFactor * (signalMax + noiseAvg);

          // Compute bitmasks
          const bitmasks = computeBitmasksFromRasterWithGlobalThreshold(
            detrendedRaster,
            chordPerSymbol,
            midpointThreshold  // try values like 0.0 or -1.0 dB
          );

          const mapped = [];
          const parityErrors = [];

          for (const b of bitmasks) {
            const { char, parityError } = botChimeBitmaskToAscii(b);
            mapped.push(char ?? 'ÔøΩ'); // Replace null with a placeholder
            parityErrors.push(parityError);
          }

          const decoded = decodeBitmasksToMessage(mapped);

          // Allow all standard printable ASCII (codes 32‚Äì126)
          const standardAsciiRegex = /[ -~]/g;  // Matches any printable ASCII character
          const filtered = (decoded.match(standardAsciiRegex) || []).join('');

          // Clean
          const cleaned = filtered.replace(/`/g, '');

          const candidate = {
            cleaned,
            decoded,
            config: cfg,
            phaseOffset,
            onsetIndexAdj,
            raster,
            detrendedRaster,
            chordPerSymbol,
            numSymbols,
            parityErrors
          };

          candidate.score = compositeScore(candidate);
          allCandidates.push(candidate);
        }
      }

      bestCandidate = allCandidates.reduce((a, b) =>
        a.score > b.score ? a : b
      );

      const decodedSymbols = bestCandidate.decoded.split('');
      const headerChar = decodedSymbols[0];
      const footerChar = decodedSymbols[decodedSymbols.length - 1];

      const headerLength = headerChar?.charCodeAt(0);
      const footerLength = footerChar?.charCodeAt(0);
      const statedLength = headerLength === footerLength ? headerLength : null;

      const numDecodedSymbols = decodedSymbols.length;

      const onsetTimeSec = onsetIndex * timeStep;
      const offsetTimeSec = offsetIndex * timeStep;
      const messageDuration = offsetTimeSec - onsetTimeSec;
      const timeBoundedMax = Math.floor(messageDuration / SYMBOL_DURATION);

      // ‚úÖ Single source of truth for number of columns
      const numColsToDraw = bestCandidate.numSymbols;



      // Draw final raster using best parameters
      drawRaster(bestCandidate.detrendedRaster, {
        canvasId: 'raster',
        labelMargin: LABEL_MARGIN,
        onsetIndex: bestCandidate.onsetIndexAdj,
        timeStep,
        symbolDuration: SYMBOL_DURATION,
        offsetTime: offsetTimeSec,
        cols: numColsToDraw
      });

      drawLabels(
        bestCandidate.chordPerSymbol,
        decodedSymbols,
        bestCandidate.raster,
        {
          canvasId: 'combinedLabels',
          labelMargin: LABEL_MARGIN,
          onsetIndex,
          timeStep,
          symbolDuration: SYMBOL_DURATION,
          offsetTime: offsetTimeSec,
          cols: numColsToDraw
        }
      );



      document.getElementById("decodedMessage").textContent = bestCandidate.cleaned;


      const msg = bestCandidate.cleaned;

    }


    // === Raw signal to spectrogram ===
    // Minimal radix-2 Cooley-Tukey FFT implementation (real to complex)
    function fft(re, im) {
      const n = re.length;
      if ((n & (n - 1)) !== 0) throw new Error("FFT size must be a power of 2");

      const levels = Math.log2(n);
      const cosTable = new Array(n / 2);
      const sinTable = new Array(n / 2);
      for (let i = 0; i < n / 2; i++) {
        const angle = (2 * Math.PI * i) / n;
        cosTable[i] = Math.cos(angle);
        sinTable[i] = Math.sin(angle);
      }

      // Bit-reversed addressing permutation
      for (let i = 0, j = 0; i < n; i++) {
        if (i < j) {
          [re[i], re[j]] = [re[j], re[i]];
          [im[i], im[j]] = [im[j], im[i]];
        }
        let bit = n >> 1;
        while (j & bit) {
          j ^= bit;
          bit >>= 1;
        }
        j ^= bit;
      }

      // Cooley-Tukey decimation-in-time radix-2 FFT
      for (let size = 2; size <= n; size <<= 1) {
        const halfSize = size >> 1;
        const tableStep = n / size;
        for (let i = 0; i < n; i += size) {
          for (let j = 0; j < halfSize; j++) {
            const k = j * tableStep;
            const tRe =  cosTable[k] * re[i + j + halfSize] + sinTable[k] * im[i + j + halfSize];
            const tIm = -sinTable[k] * re[i + j + halfSize] + cosTable[k] * im[i + j + halfSize];
            re[i + j + halfSize] = re[i + j] - tRe;
            im[i + j + halfSize] = im[i + j] - tIm;
            re[i + j] += tRe;
            im[i + j] += tIm;
          }
        }
      }
    }


    function computeSpectrogram(samples, sampleRate) {
      const fftSize = 2048;
      const hopSize = 1024;
      const numFrames = Math.floor((samples.length - fftSize) / hopSize);
      const numBins = fftSize / 2;
      const window = new Float32Array(fftSize).map((_, i) =>
        0.5 - 0.5 * Math.cos((2 * Math.PI * i) / (fftSize - 1))
      );

      const Sxx_dB = [];
      for (let i = 0; i < numBins; i++) Sxx_dB[i] = [];

      for (let f = 0; f < numFrames; f++) {
        const offset = f * hopSize;
        const frame = samples.slice(offset, offset + fftSize);
        const windowed = frame.map((x, i) => x * window[i]);

        const re = new Float32Array(fftSize);
        const im = new Float32Array(fftSize);
        for (let i = 0; i < fftSize; i++) re[i] = windowed[i] || 0;

        fft(re, im);

        for (let b = 0; b < numBins; b++) {
          const mag = Math.sqrt(re[b] ** 2 + im[b] ** 2);
          const dB = 10 * Math.log10(mag + 1e-10);
          Sxx_dB[b][f] = dB;
        }
      }

      const freqs = Array.from({ length: numBins }, (_, i) => i * sampleRate / fftSize);
      const times = Array.from({ length: numFrames }, (_, i) => i * hopSize / sampleRate);

      return { Sxx_dB, freqs, times };
    }



    // === Power monitoring ===

    const metaPowerHistory = [];  // dB values
    const maxHistory = 20;        // Number of frames (~0.5 sec if each update is ~25 ms)
    let isTriggered = false;
    let onsetSampleIndex = null;

    function computeCurrentMetaPower(samples, sampleRate) {
      const N = 2048;
      const input = samples.slice(-N);  // use last N samples
      const windowed = new Float32Array(N);
      for (let i = 0; i < N; i++) {
        const w = 0.5 - 0.5 * Math.cos((2 * Math.PI * i) / (N - 1)); // Hann window
        windowed[i] = input[i] * w;
      }

      const re = new Float32Array(N);
      const im = new Float32Array(N);
      for (let i = 0; i < N; i++) re[i] = windowed[i];

      fft(re, im);  // you already have this in your code

      const binHz = sampleRate / N;
      const fMin = noteToFreq("C5");
      const fMax = noteToFreq("A#5");
      const binMin = Math.floor(fMin / binHz);
      const binMax = Math.ceil(fMax / binHz);

      let sum = 0;
      let count = 0;

      for (let b = binMin; b <= binMax; b++) {
        const mag = Math.sqrt(re[b] ** 2 + im[b] ** 2);
        const dB = 10 * Math.log10(mag + 1e-10);
        sum += dB;
        count++;
      }

      return sum / count;
    }


    function computePowerTraceFromSpectrogram(Sxx_dB, freqs, fMin = 500, fMax = 6000) {
      // Find bin range for desired frequency band
      const startBin = freqs.findIndex(f => f >= fMin);
      const endBin = freqs.findIndex(f => f >= fMax);

      const numFrames = Sxx_dB[0].length;
      const powerTrace = [];

      for (let t = 0; t < numFrames; t++) {
        let sum = 0;
        let count = 0;
        for (let b = startBin; b <= endBin; b++) {
          const dB = Sxx_dB[b]?.[t];
          if (dB !== undefined) {
            sum += dB;
            count++;
          }
        }
        powerTrace.push(sum / (count || 1));
      }

      return powerTrace;
    }


    function computeMetaAndDataTraces(Sxx_dB, freqs) {
      const metaMin = noteToFreq("C5");
      const metaMax = noteToFreq("A#5");

      const dataMin = noteToFreq("C6");
      const dataMax = noteToFreq("C8");

      const signalMin = metaMin;
      const signalMax = dataMax;

      const metaTrace = computePowerTraceFromSpectrogram(Sxx_dB, freqs, metaMin, metaMax);
      const dataTrace = computePowerTraceFromSpectrogram(Sxx_dB, freqs, dataMin, dataMax);
      const signalTrace = computePowerTraceFromSpectrogram(Sxx_dB, freqs, signalMin, signalMax);

      const timeStep = 1 / (Sxx_dB[0]?.length / DURATION); // fallback if not explicitly passed

      const metaDetrended = detrendTrace(metaTrace, timeStep);
      const dataDetrended = detrendTrace(dataTrace, timeStep);
      const signalDetrended = detrendTrace(signalTrace, timeStep);

      return {
        metaTrace,
        dataTrace,
        signalTrace,
        metaDetrended,
        dataDetrended,
        signalDetrended
      };
    }

    function detrendTrace(trace, timeStep, skipStartSec = 0.5, averageWindowSec = 0.5) {
      const skipFrames = Math.floor(skipStartSec / timeStep);
      const avgFrames = Math.floor(averageWindowSec / timeStep);
      const start = skipFrames;
      const end = skipFrames + avgFrames;
      const mean = trace.slice(start, end).reduce((a, b) => a + b, 0) / (end - start || 1);
      return trace.map(val => val - mean);
    }


    function detectPowerRiseOnset(metaDetrended, timeStep) {
      const totalLength = metaDetrended.length;
      const skipFrames = Math.floor(0.5 / timeStep);  // number of frames = 0.5s

      const startIdx = skipFrames;
      const endIdx = totalLength - skipFrames;

      // 1. Post-signal baseline: average of final 10% of usable region
      const postSegmentLength = Math.floor(0.1 * (endIdx - startIdx));
      const postSegment = metaDetrended.slice(endIdx - postSegmentLength, endIdx);
      const baseline = postSegment.reduce((a, b) => a + b, 0) / postSegment.length;

      // 2. Signal peak (in usable range)
      const usableSegment = metaDetrended.slice(startIdx, endIdx);
      const peak = Math.max(...usableSegment);

      // 3. Adjusted threshold
      const threshold = baseline + 0.50 * (peak - baseline);

      // 4. Onset: first index where signal rises above threshold
      let onsetIndex = startIdx;
      for (let i = startIdx; i < endIdx; i++) {
        if (metaDetrended[i] > threshold) {
          onsetIndex = i;
          break;
        }
      }

      // 5. Offset: last index where signal is above threshold
      let offsetIndex = endIdx - 1;
      for (let i = endIdx - 1; i > onsetIndex; i--) {
        if (metaDetrended[i] > threshold) {
          offsetIndex = i;
          break;
        }
      }

      return { onsetIndex, offsetIndex, threshold, baseline };
    }




    // === Raster ===
    function computeRaster(Sxx_dB, freqs, times, symbolDurationSec, onsetIndex = 0, numSymbols = null) {
      const timeStep = times[1] - times[0];  // Should be ~ hopSize / sampleRate
      const onsetTime = times[onsetIndex];

      const windowFactor = 0.75;  // üß™ Use 80% of symbol duration, centered
      const totalDuration = times[times.length - 1] - onsetTime;
      if (numSymbols === null) {
        numSymbols = Math.floor(totalDuration / symbolDurationSec);
      }

      const raster = [];

      for (let p = 0; p < PITCHES.length; p++) {
        const centerFreq = noteToFreq(PITCHES[p]);
        const lowFreq = centerFreq - PITCH_BANDWIDTH / 2;
        const highFreq = centerFreq + PITCH_BANDWIDTH / 2;
        const lowBin = freqs.findIndex(f => f >= lowFreq);
        const highBin = freqs.findIndex(f => f >= highFreq);

        const row = [];

        for (let s = 0; s < numSymbols; s++) {
          const windowDuration = symbolDurationSec * windowFactor;
          const symbolStartTime = onsetTime + s * symbolDurationSec;
          const symbolEndTime = symbolStartTime + windowDuration;

          const startFrame = times.findIndex(t => t >= symbolStartTime);
          const endFrame = times.findIndex(t => t >= symbolEndTime);

          if (startFrame < 0 || endFrame < 0 || startFrame >= endFrame) {
            row.push(0);  // fallback
            continue;
          }

          let sum = 0;
          let count = 0;

          for (let b = lowBin; b <= highBin; b++) {
            for (let t = startFrame; t < endFrame; t++) {
              const val = Sxx_dB[b]?.[t];
              if (val !== undefined) {
                sum += val;
                count++;
              }
            }
          }

          row.push(sum / (count || 1));
        }

        raster.push(row);
      }

      return raster;
    }



    function detrendRasterOverFrequency(raster, noisePitchNames = ["B2", "B3", "B8"]) {
      const pitchToIndex = Object.fromEntries(PITCHES.map((p, i) => [p, i]));
      const noiseIndices = noisePitchNames.map(p => pitchToIndex[p]);
      const numSymbols = raster[0].length;
      const numPitches = raster.length;

      // Step 1: Compute baseline values per symbol from noise pitch rows
      const baselinePerSymbol = [];
      for (let s = 0; s < numSymbols; s++) {
        let sum = 0;
        for (const i of noiseIndices) {
          sum += raster[i][s];
        }
        baselinePerSymbol[s] = sum / noiseIndices.length;
      }

      // Step 2: Subtract baseline per symbol from every pitch at that symbol
      const detrended = raster.map((row, pitchIndex) =>
        row.map((val, s) => val - baselinePerSymbol[s])
      );

      return detrended;
    }


    function detrendRasterOverTimeUsingNoisePitches(raster, noisePitchNames = ["B5", "C#8"]) {
      const pitchToIndex = Object.fromEntries(PITCHES.map((p, i) => [p, i]));
      const noiseIndices = noisePitchNames.map(p => pitchToIndex[p]);
      const numSymbols = raster[0].length;

      // Step 1: Compute baseline per time column from the noise pitch rows
      const baselinePerColumn = [];
      for (let s = 0; s < numSymbols; s++) {
        let sum = 0;
        for (const i of noiseIndices) {
          sum += raster[i][s];
        }
        baselinePerColumn[s] = sum / noiseIndices.length;
      }

      // Step 2: Subtract column-wise baseline from each pitch row
      const detrended = raster.map(row =>
        row.map((val, s) => val - baselinePerColumn[s])
      );

      return detrended;
    }


    // === Decoding ===
    function computeBitmasksFromRasterWithGlobalThreshold(raster, chordPerSymbol, globalThreshold = 0.0) {
      const numSymbols = raster[0].length;
      const pitchToIndex = Object.fromEntries(PITCHES.map((p, i) => [p, i]));
      const bitmasks = [];

      for (let s = 0; s < numSymbols; s++) {
        const chordName = chordPerSymbol[s];
        const chord = CHORDS[chordName];
        if (!chord) {
          bitmasks.push(null);
          continue;
        }

        const notes = chord.notes;
        let bitmask = 0;

        notes.forEach((note, i) => {
          const rowIndex = pitchToIndex[note];
          const signal = raster[rowIndex][s];
          if (signal > globalThreshold) {
            bitmask |= (1 << (7 - i));
          }
        });

        bitmasks.push(bitmask);
      }

      return bitmasks;
    }


    function computeChordChangeVectorFromRaster(raster) {
      const metaPitchRange = [
        "C5", "C#5", "D5", "D#5", "E5", "F5",
        "F#5", "G5", "G#5", "A5", "A#5"
      ];

      const pitchToIndex = Object.fromEntries(PITCHES.map((p, i) => [p, i]));
      const metaIndices = metaPitchRange.map(p => pitchToIndex[p]);
      const numSymbols = raster[0].length;
      const vector = [];

      for (let s = 0; s < numSymbols; s++) {
        const avgMeta = metaIndices.reduce((sum, idx) => sum + raster[idx][s], 0) / metaIndices.length;
        vector.push(avgMeta > CHORD_CHANGE_THRESHOLD ? 1 : 0);
      }

      return vector;
    }


    function noteToFreq(note) {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F',
                         'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const match = note.match(/^([A-G]#?)(\d)$/);
      const [_, name, octave] = match;
      const midi = noteNames.indexOf(name) + (parseInt(octave) + 1) * 12;
      return 440 * Math.pow(2, (midi - 69) / 12);
    }


    function noteToIndex(note) {
      return PITCHES.indexOf(note);
    }


    function guessChordFromColumn(raster, colIndex) {
      const metaPitchRange = [
        "C5", "C#5", "D5", "D#5", "E5", "F5",
        "F#5", "G5", "G#5", "A5", "A#5", "B5"
      ];

      const pitchToIndex = {};
      for (let i = 0; i < PITCHES.length; i++) {
        pitchToIndex[PITCHES[i]] = i;
      }

      const metaIndices = metaPitchRange.map(p => pitchToIndex[p]);

      const activity = metaIndices.map(i => raster[i][colIndex]);

      let bestScore = -Infinity;
      let bestChord = null;

      for (const [chordName, chordObj] of Object.entries(CHORDS)) {
        const metaNotes = chordObj.meta;
        if (!metaNotes) continue;

        const target = metaPitchRange.map(p => metaNotes.includes(p) ? 1 : 0);
        const score = activity.reduce((sum, val, i) => sum + val * target[i], 0);

        if (score > bestScore) {
          bestScore = score;
          bestChord = chordName;
        }
      }

      return bestChord;
    }

    function expandChordVector(raster, chordChangeVector) {
      const chordPerSymbol = [];
      let currentChord = "I";  // Default starting chord

      for (let i = 0; i < chordChangeVector.length; i++) {
        if (chordChangeVector[i] === 1) {
          currentChord = guessChordFromColumn(raster, i);
        }
        chordPerSymbol.push(currentChord ?? "unknown");
      }

      return chordPerSymbol;
    }


    function decodeBitmasksToMessage(chars) {
      return chars.map(c => typeof c === 'string' ? c : "ÔøΩ").join('');
    }



    function botChimeBitmaskToAscii(b) {
      if (typeof b !== 'number') return { char: null, parityError: true };

      // Step 1: Check parity
      const ones = b.toString(2).split('1').length - 1;
      const parityError = ones % 2 !== 0;

      // Step 2: Reverse bits back
      const unreversed = reverseBits8(b);

      // Step 3: Undo permutation (ABCDEHFG ‚Üí ABCDEFGH)
      let temp = 0;
      temp |= ((unreversed >> 5) & 1) << 0; // H ‚Üí 0
      temp |= ((unreversed >> 4) & 1) << 1; // G ‚Üí 1
      temp |= ((unreversed >> 3) & 1) << 2; // F ‚Üí 2
      temp |= ((unreversed >> 1) & 1) << 3; // E ‚Üí 3
      temp |= ((unreversed >> 0) & 1) << 4; // D ‚Üí 4
      temp |= ((unreversed >> 7) & 1) << 5; // C ‚Üí 5
      temp |= ((unreversed >> 6) & 1) << 6; // B ‚Üí 6
      // Bit 2 is parity, ignore

      // Step 4: Flip bits F and G back
      const flipped = temp ^ 0b01100000;

      const char = String.fromCharCode(flipped);
      return { char, parityError };
    }




    function reverseBits8(n) {
      let reversed = 0;
      for (let i = 0; i < 8; i++) {
        reversed <<= 1;
        reversed |= (n >> i) & 1;
      }
      return reversed;
    }



    // === Candidate scoring ===
    function scoreCharacters(str) {
      return Array.from(str).reduce((score, c) => {
        if (/[a-zA-Z]/.test(c)) return score + 1.0;
        if (/[0-9]/.test(c)) return score + 0.8;
        if (/[.,;:!?\-]/.test(c)) return score + 0.5;
        if (/\s/.test(c)) return score + 0.2;
        return score;
      }, 0);
    }

    function ngramScore(str, n = 2) {
      const freqs = {
        th: 1.5, he: 1.4, in: 1.3, er: 1.2, an: 1.1,
        re: 1.1, nd: 1.0, at: 1.0, on: 0.9, en: 0.9,
        ti: 0.9, es: 0.9, or: 0.8, te: 0.8, of: 0.8,
        ed: 0.8, is: 0.8, it: 0.8, al: 0.7, ar: 0.7,
        st: 0.7, to: 0.7, nt: 0.7, ng: 0.6, se: 0.6,
        ha: 0.6, as: 0.6, ou: 0.6, io: 0.6, le: 0.6,
        ve: 0.6, co: 0.5, me: 0.5, de: 0.5, ro: 0.5,
        li: 0.5, ll: 0.5, be: 0.5, ne: 0.5, ma: 0.4,
        ca: 0.4, us: 0.4, el: 0.4, di: 0.4, ri: 0.4,
        ch: 0.4, ea: 0.4, ic: 0.4, ra: 0.4, no: 0.3,
        ce: 0.3, la: 0.3, ut: 0.3, ta: 0.3, pe: 0.3,
        fo: 0.3, wa: 0.3, ai: 0.3, il: 0.3, ee: 0.3
      };
      let score = 0;
      for (let i = 0; i < str.length - n + 1; i++) {
        const chunk = str.slice(i, i + n).toLowerCase();
        score += freqs[chunk] || 0;
      }
      return score;
    }

    function charEntropy(str) {
      const counts = {};
      for (const c of str) counts[c] = (counts[c] || 0) + 1;
      const len = str.length;
      return -Object.values(counts)
        .map(f => f / len)
        .reduce((sum, p) => sum + p * Math.log2(p), 0);
    }

    function parityPenaltyScore(errors) {
      const total = errors.length;
      const bad = errors.filter(Boolean).length;
      const penalty = bad / total;
      return -3.0 * penalty; // You can tune this factor
    }

    function compositeScore(c) {
      const lengthBonus = (c.statedLength === c.decoded.length - 2) ? 1.0 : -2.0;
      return (
        1.0 * scoreCharacters(c.cleaned) +
        0.3 * ngramScore(c.cleaned) +
        0.2 * charEntropy(c.cleaned) +
        1.0 * parityPenaltyScore(c.parityErrors) +
        lengthBonus
      );
    }





    // === Drawing ===

    function drawPowerTraces(metaDetrended, dataDetrended, signalDetrended, timeStep, {
      onsetIndex = null,
      offsetIndex = null,
      canvasId = 'powerCanvas'
    } = {}) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) {
        return;
      }

      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      const N = Math.min(metaDetrended.length, dataDetrended.length, signalDetrended.length);
      const times = Array.from({ length: N }, (_, i) => i * timeStep);
      const maxPower = Math.max(...metaDetrended, ...dataDetrended, ...signalDetrended);
      const minPower = Math.min(...metaDetrended, ...dataDetrended, ...signalDetrended);
      const powerRange = maxPower - minPower;

      function scaleX(t) {
        return (t / times[times.length - 1]) * (width - 50) + 40;
      }

      function scaleY(p) {
        return height - 30 - ((p - minPower) / powerRange) * (height - 60);
      }

      // Draw grid and axes
      const xTicks = 10;
      const yTicks = 8;

      ctx.strokeStyle = '#444';
      ctx.lineWidth = 0.5;
      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#aaa';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';

      for (let i = 0; i <= yTicks; i++) {
        const p = minPower + (i / yTicks) * powerRange;
        const y = scaleY(p);
        ctx.beginPath();
        ctx.moveTo(40, y);
        ctx.lineTo(width - 10, y);
        ctx.stroke();
        ctx.fillText(p.toFixed(1), 35, y);
      }

      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      for (let i = 0; i <= xTicks; i++) {
        const t = i * times[times.length - 1] / xTicks;
        const x = scaleX(t);
        ctx.beginPath();
        ctx.moveTo(x, 10);
        ctx.lineTo(x, height - 30);
        ctx.stroke();
        ctx.fillText(t.toFixed(1), x, height - 25);
      }

      // Axis lines
      ctx.beginPath();
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.moveTo(40, 10);
      ctx.lineTo(40, height - 30);
      ctx.lineTo(width - 10, height - 30);
      ctx.stroke();

      // üî¥ Draw metaDetrended in white
      ctx.beginPath();
      ctx.strokeStyle = 'white';
      ctx.moveTo(scaleX(times[0]), scaleY(metaDetrended[0]));
      for (let i = 1; i < N; i++) {
        ctx.lineTo(scaleX(times[i]), scaleY(metaDetrended[i]));
      }
      ctx.stroke();

      // üè∑Ô∏è Label for metaDetrended
      ctx.fillStyle = 'white';
      ctx.font = '12px sans-serif';
      ctx.fillText('metadata (C5 through A#5)', 3 * LABEL_MARGIN, 15);

      // üîµ Draw dataDetrended in yellow
      ctx.beginPath();
      ctx.strokeStyle = 'yellow';
      ctx.moveTo(scaleX(times[0]), scaleY(dataDetrended[0]));
      for (let i = 1; i < N; i++) {
        ctx.lineTo(scaleX(times[i]), scaleY(dataDetrended[i]));
      }
      ctx.stroke();

      // üè∑Ô∏è Label for dataDetrended
      ctx.fillStyle = 'yellow';
      ctx.fillText('data (C6 through C8)', 3 * LABEL_MARGIN, 30);


      // Onset marker
      if (onsetIndex !== null) {
        const x = scaleX(onsetIndex * timeStep);
        ctx.beginPath();
        ctx.strokeStyle = 'lime';
        ctx.moveTo(x, 10);
        ctx.lineTo(x, height - 30);
        ctx.stroke();
      }

      // Offset marker
      if (offsetIndex !== null) {
        const x = scaleX(offsetIndex * timeStep);
        ctx.beginPath();
        ctx.strokeStyle = 'orange';
        ctx.moveTo(x, 10);
        ctx.lineTo(x, height - 30);
        ctx.stroke();
      }
    }

    function drawRaster(raster, options) {
      const {
        canvasId,
        labelMargin = 50,
        cols,  // üëà new
        onsetIndex = null,
        timeStep = null,
        symbolDuration = null,
        offsetTime = null,          // ‚¨ÖÔ∏è new option!
        highlightColor = '#0f0'
      } = options;

      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      const rows = raster.length;

      const cellWidth = (canvas.width - labelMargin) / cols;
      const cellHeight = canvas.height / rows;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const flat = raster.flat();
      const minVal = Math.min(...flat);
      const maxVal = Math.max(...flat);

      for (let r = 0; r < rows; r++) {
        const flipped = rows - 1 - r;
        for (let c = 0; c < cols; c++) {
          const norm = (raster[flipped][c] - minVal) / (maxVal - minVal);
          const { r: red, g, b } = powerColor(norm);
          ctx.fillStyle = `rgb(${red},${g},${b})`;
          ctx.fillRect(labelMargin + c * cellWidth, r * cellHeight, cellWidth, cellHeight);
        }
      }

      ctx.fillStyle = "#ccc";
      ctx.font = "10px monospace";
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for (let r = 0; r < rows; r++) {
        const flipped = rows - 1 - r;
        const y = r * cellHeight + cellHeight / 2;
        ctx.fillText(PITCHES[flipped], labelMargin - 5, y);
      }

      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      for (let c = 0; c <= cols; c += Math.ceil(cols / 10)) {
        const x = labelMargin + c * cellWidth;
        const t = c * symbolDuration;
        ctx.fillText(`${t.toFixed(1)}s`, x, canvas.height - 12);
      }
    }


    function powerColor(norm) {
      norm = Math.max(0, Math.min(1, norm));  // Clamp between 0‚Äì1
      const r = Math.round(255 * norm);
      const g = Math.round(255 * (1 - Math.abs(norm - 0.5)));
      const b = Math.round(255 * (1 - norm));
      return { r, g, b };
    }



    function drawLabels(chords, symbols, raster, {
      canvasId = 'combinedLabels',
      labelMargin = 50,
      fontSize = 24,
      onsetIndex = null,
      timeStep = null,
      symbolDuration = null,
      offsetTime = null,
      cols  // üëà ADD THIS
    } = {}) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const drawWidth = width - labelMargin;

      const cellWidth = drawWidth / cols;
      const rowHeight = height / 2;

      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, width, height);

      // Grid lines
      ctx.strokeStyle = "#444";
      ctx.lineWidth = 1;
      for (let i = 0; i <= cols; i++) {
        const x = labelMargin + i * cellWidth;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }

      // Horizontal separator
      const separatorY = rowHeight;
      ctx.beginPath();
      ctx.moveTo(labelMargin, separatorY);
      ctx.lineTo(width, separatorY);
      ctx.stroke();

      ctx.font = `bold ${fontSize}px monospace`;
      ctx.textBaseline = "middle";

      let prevChord = null;

      for (let i = 0; i < cols; i++) {
        const xCenter = labelMargin + i * cellWidth + cellWidth / 2;
        const xLeft = labelMargin + i * cellWidth + 4; // padding from left edge

        // Row 1: Chord label (left-aligned, only if changed)
        const chord = chords[i];
        if (chord !== prevChord) {
          ctx.fillStyle = "#0ff";
          ctx.textAlign = "left";
          ctx.fillText(chord, xLeft, rowHeight / 2);
          prevChord = chord;
        }

        // Row 2: Symbol (centered, replacing special quote with space)
        ctx.fillStyle = "#ff0";
        ctx.textAlign = "center";


        let symbol = symbols[i];

        // Replace first and last symbol with a dot instead of ASCII code
        if (i === 0 || i === symbols.length - 1) {
          symbol = '‚Ä¢';  // or '.' if you prefer
          ctx.font = `${fontSize}px monospace`;  // keep consistent font size
        } else {
          // Optional: clean up visually confusing quotes
          const code = symbol.charCodeAt(0);
          if (code < 32 || code === 127 || symbol === '`' || code === 0x2018 || code === 0x2019) {
            symbol = ' ';
          }
        }




        ctx.fillText(symbol, xCenter, rowHeight + rowHeight / 2);
      }
    }


    function resizeCanvases() {
      const maxWidth = 1000;
      const screenWidth = Math.min(window.innerWidth, maxWidth);

      const canvases = [
        document.getElementById('powerCanvas'),
        document.getElementById('raster'),
        document.getElementById('combinedLabels')
      ];

      canvases.forEach(canvas => {
        if (canvas) {
          canvas.style.width = screenWidth * 0.95 + 'px';
          canvas.width = screenWidth;
        }
      });

      // Resize buttons: each takes up 50% of 80% of screenWidth
      const totalButtonWidth = screenWidth * 0.8;
      const buttonWidth = totalButtonWidth / 2;
      const buttons = [
        document.getElementById('startBtn'),
        document.getElementById('stopBtn')
      ];

      buttons.forEach(button => {
        if (button) {
          button.style.width = buttonWidth + 'px';
          button.style.height = '80px';         // ‚¨ÖÔ∏è Double the usual height
          button.style.fontSize = '32px';       // ‚¨ÜÔ∏è Slightly larger text
          button.style.margin = '5px';
          button.style.boxSizing = 'border-box';
        }
      });


    }


    window.addEventListener('load', resizeCanvases);



  </script>
</body>
</html>













